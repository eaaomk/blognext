const t=JSON.parse('{"key":"v-1d837204","path":"/posts/java/3.html","title":"设计模式1","lang":"zh-CN","frontmatter":{"lastUpdated":true,"description":"设计模式1 工厂模式（Factory Pattern） 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。 意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。 主要解决：主要解决接口选择的问题。 何时使用：我们明确地计划不同条件下创建不同实例时。 如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。 关键代码：创建过程在其子类执行。 应用实例： 1、你需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。","head":[["meta",{"property":"og:url","content":"https://eaaomk.github.io/blognext/blognext/posts/java/3.html"}],["meta",{"property":"og:site_name","content":"欢迎你"}],["meta",{"property":"og:title","content":"设计模式1"}],["meta",{"property":"og:description","content":"设计模式1 工厂模式（Factory Pattern） 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。 意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。 主要解决：主要解决接口选择的问题。 何时使用：我们明确地计划不同条件下创建不同实例时。 如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。 关键代码：创建过程在其子类执行。 应用实例： 1、你需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-01-29T13:57:58.000Z"}],["meta",{"property":"article:modified_time","content":"2023-01-29T13:57:58.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"设计模式1\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-01-29T13:57:58.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"工厂模式（Factory Pattern）","slug":"工厂模式-factory-pattern","link":"#工厂模式-factory-pattern","children":[{"level":3,"title":"实现","slug":"实现","link":"#实现","children":[]}]},{"level":2,"title":"抽象工厂模式（Abstract Factory Pattern）","slug":"抽象工厂模式-abstract-factory-pattern","link":"#抽象工厂模式-abstract-factory-pattern","children":[{"level":3,"title":"实现","slug":"实现-1","link":"#实现-1","children":[]}]},{"level":2,"title":"单例模式（Singleton Pattern）","slug":"单例模式-singleton-pattern","link":"#单例模式-singleton-pattern","children":[{"level":3,"title":"实现","slug":"实现-2","link":"#实现-2","children":[]}]},{"level":2,"title":"建造者模式（Builder Pattern）","slug":"建造者模式-builder-pattern","link":"#建造者模式-builder-pattern","children":[{"level":3,"title":"实现","slug":"实现-3","link":"#实现-3","children":[]}]},{"level":2,"title":"原型模式（Prototype Pattern）","slug":"原型模式-prototype-pattern","link":"#原型模式-prototype-pattern","children":[{"level":3,"title":"实现","slug":"实现-4","link":"#实现-4","children":[]}]}],"git":{"createdTime":1675000678000,"updatedTime":1675000678000,"contributors":[{"name":"qiang.zhang","email":"eaaomk@163.com","commits":1}]},"readingTime":{"minutes":21.47,"words":6440},"filePathRelative":"posts/java/3.md","localizedDate":"2023年1月29日","excerpt":"<h1> 设计模式1</h1>\\n<h2> 工厂模式（Factory Pattern）</h2>\\n<ul>\\n<li>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</li>\\n</ul>\\n<p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>\\n<ul>\\n<li>\\n<p>意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p>\\n</li>\\n<li>\\n<p>主要解决：主要解决接口选择的问题。</p>\\n</li>\\n<li>\\n<p>何时使用：我们明确地计划不同条件下创建不同实例时。</p>\\n</li>\\n<li>\\n<p>如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。</p>\\n</li>\\n<li>\\n<p>关键代码：创建过程在其子类执行。</p>\\n</li>\\n<li>\\n<p>应用实例：</p>\\n<ul>\\n<li>1、你需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。</li>\\n<li>2、Hibernate 换数据库只需换方言和驱动就可以。</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{t as data};
