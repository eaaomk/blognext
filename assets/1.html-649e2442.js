import{_ as n,V as s,W as a,Z as e}from"./framework-bcbeea85.js";const p="/blognext/images/fork.png",t={},i=e(`<h1 id="fork-函数" tabindex="-1"><a class="header-anchor" href="#fork-函数" aria-hidden="true">#</a> fork 函数</h1><h3 id="源代码" tabindex="-1"><a class="header-anchor" href="#源代码" aria-hidden="true">#</a> 源代码</h3><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">//派生进程</span>
    <span class="token class-name">pid_t</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//派生失败</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">&quot;fork error&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//派生成功返回值为0表示子进程</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;\\nchild: forkval=%d pid=%d cnt=%d\\n&quot;</span><span class="token punctuation">,</span> pid<span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">++</span>cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//派生成功返回值大于0表示父进程，父进程中将返回子进程的PID。</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;\\nparent: forkval=%d pid=%d cnt=%d\\n&quot;</span><span class="token punctuation">,</span> pid<span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>
        
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>注意，window环境下编译会失败，因为会提示不存在fork 函数，本次编译结果来源于linux 系统。</li></ul><h3 id="编译执行结果" tabindex="-1"><a class="header-anchor" href="#编译执行结果" aria-hidden="true">#</a> 编译执行结果</h3><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>parent<span class="token operator">:</span> forkval<span class="token operator">=</span><span class="token number">71052</span> pid<span class="token operator">=</span><span class="token number">71051</span> cnt<span class="token operator">=</span><span class="token number">1</span>

child<span class="token operator">:</span> forkval<span class="token operator">=</span><span class="token number">0</span> pid<span class="token operator">=</span><span class="token number">71052</span> cnt<span class="token operator">=</span><span class="token number">2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>fork函数用于创建一个与当前进程映像一样的子进程，所创建的子进程将复制父进程的代码段、数据段、BSS段、堆、栈等所有用户空间信息，在内核中操作系统会重新为其申请一个子进程执行的位置。</p><p>fork系统调用会通过复制一个现有进程来创建一个全新的进程，新进程被存放在一个叫做任务队列的双向循环链表中，链表中的每一项都是类型为task_struct的进程控制块PCB的结构。</p><h3 id="父子进程有什么区别呢" tabindex="-1"><a class="header-anchor" href="#父子进程有什么区别呢" aria-hidden="true">#</a> 父子进程有什么区别呢？</h3><ul><li>父进程设置了锁，子进程不继承。</li><li>进程ID各不相同</li><li>子进程的未决告警被清除</li><li>子进程的未决信号集设置未空集</li></ul><h3 id="函数原型" tabindex="-1"><a class="header-anchor" href="#函数原型" aria-hidden="true">#</a> 函数原型</h3><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token class-name">pid_t</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>pid_t是一个宏定义，其实质是int被定义在#include &lt;sys/types.h&gt;头文件中。</p><h3 id="返回值" tabindex="-1"><a class="header-anchor" href="#返回值" aria-hidden="true">#</a> 返回值</h3><ul><li>若成功调用一次则返回两个值，子进程返回0，父进程返回子进程ID，否则出错返回-1。</li></ul><figure><img src="`+p+`" alt="fork" tabindex="0" loading="lazy"><figcaption>fork</figcaption></figure><h3 id="进程标识符" tabindex="-1"><a class="header-anchor" href="#进程标识符" aria-hidden="true">#</a> 进程标识符</h3><p>每个进程都由独特换不相同的进程标识符（process ID），通过getpid()函数可获取当前进程的进程标识符，通过getppid()函数可获得父进程的进程标识符。</p><h3 id="概要" tabindex="-1"><a class="header-anchor" href="#概要" aria-hidden="true">#</a> 概要</h3><p>子进程是父进程的副本，它将获得父进程数据空间、堆、栈等资源的副本。值得注意的是子进程持有的是存储空间的副本，意味着父子进程之间是不会共享这些存储空间的。</p><p>UNIX将复制父进程的地址空间内容给子进程，因此子进程具有独立的地址空间。在不同的UNIX系统下，是无法确定fork后是子进程先运行还是父进程先运行，这依赖于系统的实现。</p><h3 id="fork执行执行流程" tabindex="-1"><a class="header-anchor" href="#fork执行执行流程" aria-hidden="true">#</a> fork执行执行流程</h3><p>当进程调用fork后控制转入内核，内核将会做4件事儿：</p><ul><li>分配新的内存块和内核数据结构给子进程</li><li>将父进程部分数据结构内容（数据空间、堆栈等）拷贝到子进程</li><li>添加子进程到系统进程列表中</li><li>fork返回开始调度器调度</li></ul><h3 id="为什么fork会返回两次呢" tabindex="-1"><a class="header-anchor" href="#为什么fork会返回两次呢" aria-hidden="true">#</a> 为什么fork会返回两次呢？</h3><p>因为复制时会复制父进程的堆栈段，所以两个进程都停留在fork函数中等待返回，因此会返回两次，一个是在父进程中返回，一次是在子进程中返回，两次返回值是不一样的。 在父进程中将返回新建子进程的进程ID， 在子进程中将返回0， 若出现错误则返回一个负数， 因此可以通过fork的返回值来判断当前进程是子进程还是父进程。</p><h3 id="为什么pid在父子进程中不同呢" tabindex="-1"><a class="header-anchor" href="#为什么pid在父子进程中不同呢" aria-hidden="true">#</a> 为什么pid在父子进程中不同呢？</h3><p>其实就相当于链表，进程形成了链表，父进程的pid指向子进程的进程ID，因此子进程没有子进程，所以PID为0，这里的pid相当于链表中的指针。</p><h3 id="fork派生可能出现的错误原因是什么呢" tabindex="-1"><a class="header-anchor" href="#fork派生可能出现的错误原因是什么呢" aria-hidden="true">#</a> fork派生可能出现的错误原因是什么呢？</h3><ul><li>当前进程数已经达到系统规定的上限错误值errno会被设置为EAGAIN。</li></ul><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>$ cat <span class="token operator">/</span>proc<span class="token operator">/</span>sys<span class="token operator">/</span>kernel<span class="token operator">/</span>pid_max 
<span class="token number">81920</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>系统内存不足时错误值errno会被设置为EAGAIN</li></ul><h3 id="fork系统调用使用注意" tabindex="-1"><a class="header-anchor" href="#fork系统调用使用注意" aria-hidden="true">#</a> fork系统调用使用注意</h3><p>fork系统调用之后父进程和子进程是交替执行，父子进程是处于不同空间中的 fork系统调用的一次调用存在两次返回，此时二个进程处于独立的空间，各自执行自己的参数</p>`,34),o=[i];function c(l,r){return s(),a("div",null,o)}const u=n(t,[["render",c],["__file","1.html.vue"]]);export{u as default};
