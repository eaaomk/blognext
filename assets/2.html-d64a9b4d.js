const e=JSON.parse('{"key":"v-20ed2342","path":"/posts/java/2.html","title":"六大原则","lang":"zh-CN","frontmatter":{"lastUpdated":true,"description":"六大原则 1.单一职责原则——SRP 只有掌握好了六大原则，才能写出优美的代码 单一职责原则的定义是就一个类而言，应该仅有一个引起他变化的原因。也就是说一个类应该只负责一件事情。如果一个类负责了方法M1,方法M2两个不同的事情，当M1方法发生变化的时候，我们需要修改这个类的M1方法，但是这个时候就有可能导致M2方法不能工作。这个不是我们期待的，但是由于这种设计却很有可能发生。所以这个时候，我们需要把M1方法，M2方法单独分离成两个类。让每个类只专心处理自己的方法。 单一职责原则的好处如下： 可以降低类的复杂度，一个类只负责一项职责，这样逻辑也简单很多 提高类的可读性，和系统的维护性，因为不会有其他奇怪的方法来干扰我们理解这个类的含义 当发生变化的时候，能将变化的影响降到最小，因为只会在这个类中做出修改。","head":[["meta",{"property":"og:url","content":"https://eaaomk.github.io/blognext/blognext/posts/java/2.html"}],["meta",{"property":"og:site_name","content":"欢迎你"}],["meta",{"property":"og:title","content":"六大原则"}],["meta",{"property":"og:description","content":"六大原则 1.单一职责原则——SRP 只有掌握好了六大原则，才能写出优美的代码 单一职责原则的定义是就一个类而言，应该仅有一个引起他变化的原因。也就是说一个类应该只负责一件事情。如果一个类负责了方法M1,方法M2两个不同的事情，当M1方法发生变化的时候，我们需要修改这个类的M1方法，但是这个时候就有可能导致M2方法不能工作。这个不是我们期待的，但是由于这种设计却很有可能发生。所以这个时候，我们需要把M1方法，M2方法单独分离成两个类。让每个类只专心处理自己的方法。 单一职责原则的好处如下： 可以降低类的复杂度，一个类只负责一项职责，这样逻辑也简单很多 提高类的可读性，和系统的维护性，因为不会有其他奇怪的方法来干扰我们理解这个类的含义 当发生变化的时候，能将变化的影响降到最小，因为只会在这个类中做出修改。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-01-29T13:57:58.000Z"}],["meta",{"property":"article:modified_time","content":"2023-01-29T13:57:58.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"六大原则\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-01-29T13:57:58.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"1.单一职责原则——SRP","slug":"_1-单一职责原则——srp","link":"#_1-单一职责原则——srp","children":[]},{"level":2,"title":"2.开闭原则——OCP","slug":"_2-开闭原则——ocp","link":"#_2-开闭原则——ocp","children":[]},{"level":2,"title":"3.里式替换原则——LSP","slug":"_3-里式替换原则——lsp","link":"#_3-里式替换原则——lsp","children":[]},{"level":2,"title":"4.依赖倒置原则——DIP","slug":"_4-依赖倒置原则——dip","link":"#_4-依赖倒置原则——dip","children":[]},{"level":2,"title":"5.接口隔离原则——ISP","slug":"_5-接口隔离原则——isp","link":"#_5-接口隔离原则——isp","children":[]},{"level":2,"title":"6.迪米特原则——LOD","slug":"_6-迪米特原则——lod","link":"#_6-迪米特原则——lod","children":[]}],"git":{"createdTime":1675000678000,"updatedTime":1675000678000,"contributors":[{"name":"qiang.zhang","email":"eaaomk@163.com","commits":1}]},"readingTime":{"minutes":9.52,"words":2857},"filePathRelative":"posts/java/2.md","localizedDate":"2023年1月29日","excerpt":"<h1> 六大原则</h1>\\n<h2> 1.单一职责原则——SRP</h2>\\n<ul>\\n<li>只有掌握好了六大原则，才能写出优美的代码</li>\\n</ul>\\n<p>单一职责原则的定义是就一个类而言，应该仅有一个引起他变化的原因。也就是说一个类应该只负责一件事情。如果一个类负责了方法M1,方法M2两个不同的事情，当M1方法发生变化的时候，我们需要修改这个类的M1方法，但是这个时候就有可能导致M2方法不能工作。这个不是我们期待的，但是由于这种设计却很有可能发生。所以这个时候，我们需要把M1方法，M2方法单独分离成两个类。让每个类只专心处理自己的方法。\\n单一职责原则的好处如下：</p>\\n<ul>\\n<li>可以降低类的复杂度，一个类只负责一项职责，这样逻辑也简单很多</li>\\n<li>提高类的可读性，和系统的维护性，因为不会有其他奇怪的方法来干扰我们理解这个类的含义</li>\\n<li>当发生变化的时候，能将变化的影响降到最小，因为只会在这个类中做出修改。</li>\\n</ul>","autoDesc":true}');export{e as data};
