<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.60" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://eaaomk.github.io/blognext/blognext/posts/os/5.html"><meta property="og:site_name" content="欢迎你"><meta property="og:title" content="进程通信"><meta property="og:description" content="进程通信 进程通信是指进程之间的信息交换。由于进程的互斥与同步,需要在进程间交换一定的信息,故不少学者将它们也归为进程通信,但只能把它们称为低级进程通信。我们以信号量机制为例来说明,它们之所以低级的原因在于: 效率低,生产者每次只能向缓冲池投放一个产品(消息),消费者每次只能从缓冲区中取得一个消息; 通信对用户不透明,oS只为进程之间的通信提供了共享存储器。而关于进程之间通信所需之共享数据结构的设置、数据的传送、进程的互斥与同步,都必须由程序员去实现,显然,对于用户而言,这是非常不方便的。 在进程之间要传送大量数据时,应当利用OS提供的高级通信工具,该工具最主要的特点是:"><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2023-01-28T15:26:49.000Z"><meta property="article:modified_time" content="2023-01-28T15:26:49.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"进程通信","image":[""],"dateModified":"2023-01-28T15:26:49.000Z","author":[]}</script><title>进程通信 | 欢迎你</title><meta name="description" content="进程通信 进程通信是指进程之间的信息交换。由于进程的互斥与同步,需要在进程间交换一定的信息,故不少学者将它们也归为进程通信,但只能把它们称为低级进程通信。我们以信号量机制为例来说明,它们之所以低级的原因在于: 效率低,生产者每次只能向缓冲池投放一个产品(消息),消费者每次只能从缓冲区中取得一个消息; 通信对用户不透明,oS只为进程之间的通信提供了共享存储器。而关于进程之间通信所需之共享数据结构的设置、数据的传送、进程的互斥与同步,都必须由程序员去实现,显然,对于用户而言,这是非常不方便的。 在进程之间要传送大量数据时,应当利用OS提供的高级通信工具,该工具最主要的特点是:">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d1e1f;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/blognext/assets/style-8d0dcade.css" as="style"><link rel="stylesheet" href="/blognext/assets/style-8d0dcade.css">
    <link rel="modulepreload" href="/blognext/assets/app-72b3b0cc.js"><link rel="modulepreload" href="/blognext/assets/framework-bcbeea85.js"><link rel="modulepreload" href="/blognext/assets/5.html-a1ad4f8f.js"><link rel="modulepreload" href="/blognext/assets/5.html-f76e5158.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header class="navbar" id="navbar"><div class="navbar-start"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><a href="/blognext/" class="brand"><img class="logo" src="/blognext/logo.svg" alt="欢迎你"><!----><span class="site-name hide-in-pad">欢迎你</span></a><!--[--><!----><!--]--></div><div class="navbar-center"><!--[--><!----><!--]--><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/blognext/" class="nav-link" aria-label="博客主页"><span class="font-icon icon iconfont icon-home" style=""></span>博客主页<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="博文"><span class="title"><span class="font-icon icon iconfont icon-edit" style=""></span>博文</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>android</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blognext/posts/android/0.html" class="nav-link" aria-label="Android"><span class="font-icon icon iconfont icon-edit" style=""></span>Android<!----></a></li></ul></li></ul></button></div></div></nav><!--[--><!----><!--]--></div><div class="navbar-end"><!--[--><!----><!--]--><!----><div class="nav-item"><a class="repo-link" href="https://github.com/eaaomk" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!----><!--[--><!----><!--]--><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar" id="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><a href="/blognext/" class="nav-link sidebar-link sidebar-page" aria-label="博客主页"><span class="font-icon icon iconfont icon-home" style=""></span>博客主页<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><section class="sidebar-group"><p class="sidebar-heading active"><span class="font-icon icon iconfont icon-note" style=""></span><span class="title">文章</span><!----></p><ul class="sidebar-links"><li><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Android</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">C</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Git</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable active"><!----><span class="title">Os</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><a href="/blognext/posts/os/2.html" class="nav-link sidebar-link sidebar-page" aria-label="进程的描述"><!---->进程的描述<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blognext/posts/os/3.html" class="nav-link sidebar-link sidebar-page" aria-label="进程控制"><!---->进程控制<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/blognext/posts/os/5.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="进程通信"><!---->进程通信<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/blognext/posts/os/5.html#进程通信的类型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="进程通信的类型"><!---->进程通信的类型<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blognext/posts/os/5.html#消息传递通信的实现方式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="消息传递通信的实现方式"><!---->消息传递通信的实现方式<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blognext/posts/os/5.html#直接消息传递系统实例" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="直接消息传递系统实例"><!---->直接消息传递系统实例<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a href="/blognext/posts/os/4.html" class="nav-link sidebar-link sidebar-page" aria-label="进程同步"><!---->进程同步<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blognext/posts/os/0.html" class="nav-link sidebar-link sidebar-page" aria-label="进程与线程-基于操作系统层次"><!---->进程与线程-基于操作系统层次<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blognext/posts/os/8.html" class="nav-link sidebar-link sidebar-page" aria-label="进程与线程的重要知识点问题"><!---->进程与线程的重要知识点问题<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blognext/posts/os/1.html" class="nav-link sidebar-link sidebar-page" aria-label="前趋图与程序的执行"><!---->前趋图与程序的执行<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blognext/posts/os/6.html" class="nav-link sidebar-link sidebar-page" aria-label="线程的基本概念"><!---->线程的基本概念<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blognext/posts/os/7.html" class="nav-link sidebar-link sidebar-page" aria-label="线程的实现"><!---->线程的实现<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section></li></ul></section></li><li><!--[--><a href="/blognext/intro.html" class="nav-link sidebar-link sidebar-page" aria-label="个人简介"><span class="font-icon icon iconfont icon-info" style=""></span>个人简介<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->进程通信</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><span class="page-author-item">qiang.zhang</span></span><span property="author" content="qiang.zhang"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2023-01-28T15:26:49.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 24 分钟</span><meta property="timeRequired" content="PT24M"></span><!----><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容<button class="print-button" title="print"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/blognext/posts/os/5.html#进程通信的类型" class="router-link-active router-link-exact-active toc-link level3">进程通信的类型</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blognext/posts/os/5.html#消息传递通信的实现方式" class="router-link-active router-link-exact-active toc-link level3">消息传递通信的实现方式</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blognext/posts/os/5.html#直接消息传递系统实例" class="router-link-active router-link-exact-active toc-link level3">直接消息传递系统实例</a></li><!----><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><h1 id="进程通信" tabindex="-1"><a class="header-anchor" href="#进程通信" aria-hidden="true">#</a> 进程通信</h1><p>进程通信是指进程之间的信息交换。由于进程的互斥与同步,需要在进程间交换一定的信息,故不少学者将它们也归为进程通信,但只能把它们称为低级进程通信。我们以信号量机制为例来说明,它们之所以低级的原因在于:</p><ol><li>效率低,生产者每次只能向缓冲池投放一个产品(消息),消费者每次只能从缓冲区中取得一个消息;</li><li>通信对用户不透明,oS只为进程之间的通信提供了共享存储器。而关于进程之间通信所需之共享数据结构的设置、数据的传送、进程的互斥与同步,都必须由程序员去实现,显然,对于用户而言,这是非常不方便的。</li></ol><p>在进程之间要传送大量数据时,应当利用OS提供的高级通信工具,该工具最主要的特点是:</p><ol><li>使用方便。OS隐藏了实现进程通信的具体细节,向用户提供了一组用于实现高级通信的命令(原语),用户可方便地直接利用它实现进程之间的通信。或者说,通信过程对用户是透明的。这样就大大减少了通信程序编制上的复杂性。</li><li>高效地传送大量数据。用户可直接利用高级通信命令(原语)高效地传送大量的数据</li></ol><h3 id="进程通信的类型" tabindex="-1"><a class="header-anchor" href="#进程通信的类型" aria-hidden="true">#</a> 进程通信的类型</h3><p>随着OS的发展,用于进程之间实现通信的机制也在发展,并已由早期的低级进程通信机制发展为能传送大量数据的高级通信工具机制。目前,高级通信机制可归结为四大类: 共享存储器系统、管道通信系统、消息传递系统以及客户机-服务器系统。</p><h4 id="共享存储器系统-shared-memory-system" tabindex="-1"><a class="header-anchor" href="#共享存储器系统-shared-memory-system" aria-hidden="true">#</a> 共享存储器系统( Shared-Memory System)</h4><p>在共享存储器系统中,相互通信的进程共享某些数据结构或共享存储区,进程之间能够通过这些空间进行通信。据此,又可把它们分成以下两种类型</p><ol><li>基于共享数据结构的通信方式。在这种通信方式中,要求诸进程公用某些数据结构,借以实现诸进程间的信息交换,如在生产者消费者问题中的有界缓冲区。操作系统仅提供共享存储器,由程序员负责对公用数据结构的设置及对进程间同步的处理。这种通信方式仅适于传递相对少量的数据,通信效率低下,属于低级通信.</li><li>基于共享存储区的通信方式。为了传输大量数据,在内存中划出了一块共享存储区域,诸进程可通过对该共享区的读或写交换信息,实现通信,数据的形式和位置甚至访问控制都是由进程负责,而不是OS。这种通信方式属于高级通信。需要通信的进程在通信前,先向系统申请获得共享存储区中的一个分区,并将其附加到自己的地址空间中,便可对其中的数据进行正常读、写,读写完成或不再需要时,将其归还给共享存储区</li></ol><h4 id="管道-pipe-通信系统" tabindex="-1"><a class="header-anchor" href="#管道-pipe-通信系统" aria-hidden="true">#</a> 管道(pipe)通信系统</h4><p>所谓“管道”,是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件,又名pipe文件。向管道(共享文件)提供输入的发送进程(即写进程)以字符流形式将大量的数据送入管道:而接受管道输出的接收进程(即读进程)则从管道中接收读)数据。由于发送进程和接收进程是利用管道进行通信的,故又称为管道通信。这种方式首创于UNIX系统,由于它能有效地传送大量数据,因而又被引入到许多其它操作系统中为了协调双方的通信,管道机制必须提供以下三方面的协调能力:</p><ol><li>互斥,即当一个进程正在对pipe执行读/写操作时,其它(另一)进程必须等待。</li><li>同步,指当写(输入)进程把一定数量(如4KB)的数据写入pipe,便去睡眠等待,直到读(输出)进程取走数据后再把它唤醒。当读进程读一空pipe时,也应睡眠等待,直至写进程将数据写入管道后才将之唤醒。</li><li>确定对方是否存在,只有确定了对方己存在时才能进行通信。</li></ol><h4 id="消息传递系统-message-passing-system" tabindex="-1"><a class="header-anchor" href="#消息传递系统-message-passing-system" aria-hidden="true">#</a> 消息传递系统 (Message passing system)</h4><p>在该机制中,进程不必借助任何共享存储区或数据结构,而是以格式化的消息( message).单位,将通信的数据封装在消息中,并利用操作系统提供的一组通信命令(原语),在进程间进行消息传递,完成进程间的数据交换该方式隐藏了通信实现细节,使通信过程对用户透明化,降低了通信程序设计的复杂性和错误率,成为当前应用最为广泛的一类进程间通信的机制。例如:在计算机网络中,消息(message)又称为报文;在微内核操作系统中,微内核与服务器之间的通信无一例外都是采用了消息传递机制.由于该机制能很好地支持多处理机系统、分布式系统和计算机网络,因此也成为这些领域最主要的通信工具基于消息传递系统的通信方式属于高级通信方式,因其实现方式的不同,可进一步分成两类:</p><ol><li>直接通信方式,是指发送进程利用Os所提供的发送原语,直接把消息发送给目标进程</li><li>间接通信方式,是指发送和接收进程,都通过共享中间实体(称为邮箱)的方式进行消息的发送和接收,完成进程间的通信。</li></ol><h4 id="客户机服务器系统-client-server-system" tabindex="-1"><a class="header-anchor" href="#客户机服务器系统-client-server-system" aria-hidden="true">#</a> 客户机服务器系统(Client-Server system)</h4><p>前面所述的共享内存、消息传递等技术,虽然也可以用于实现不同计算机间进程的双向通信,但客户机-服务器系统的通信机制,在网络环境的各种应用领域已成为当前主流的通信实现机制,其主要的实现方法分为三类:套接字、远程过程调用和远程方法调用.</p><ol><li>套接字( Socket)套接字起源于20世纪70年代加州大学伯克利分校版本的UNX(即 BSD Unix),是UNⅨX操作系统下的网络通信接口。一开始,套接字被设计用在同一台主机上多个应用程序之间的通信(即进程间的通信),主要是为了解决多对进程同时通信时端口和物理线路的多路复用问题。随着计算机网络技术的发展以及UNX操作系统的广泛使用,套接字已逐渐成为最流行的网络通信程序接口之个套接字就是一个通信标识类型的数据结构,包含了通信目的的地址、通信使用的端口号、通信网络的传输层协议、进程所在的网络地址,以及针对客户或服务器程序提供的不同系统调用(或API函数)等,是进程通信和网络通信的基本构件。套接字是为客户/服务器模型而设计的,通常,套接字包括两类: <ul><li>基于文件型:通信进程都运行在同一台机器的环境中,套接字是基于本地文件系统支持的,一个套接字关联到一个特殊的文件,通信双方通过对这个特殊文件的读写实现通信,其原理类似于前面所讲的管道。</li><li>基于网络型:该类型通常采用的是非对称方式通信,即发送者需要提供接收者命名。通信双方的进程运行在不同主机的网络环境下,被分配了一对套接字,一个属于接收进程(或服务器端),一个属于发送进程(或客户端)。一般地,发送进程(或客户端)发出连接请求时,随机申请一个套接字,主机为之分配一个端口,与该套接字绑定,不再分配给其它进程。接收进程(或服务器端)拥有全局公认的套接字和指定的端口(如印服务器监听端口为21,Web或hp服务器监听端口为80),并通过监听端口等待客户请求。因此,任何进程都可以向它发出连接请求和信息请求,以方便进程之间通信连接的建立。接收进程(或服务器端)一旦收到请求,就接受来自发送进程(或客户端)的连接,完成连接,即在主机间传输的数据可以准确地发送到通信进程,实现进程间的通信:当通信结束时,系统通过关闭接收进程(或服务器端)的套接字撤销连接。</li></ul></li></ol><p> 套接字的优势在于,它不仅适用于同一台计算机内部的进程通信,也适用于网络环境中不同计算机间的进程通信。由于每个套接字拥有唯一的套接字号(也称套接字标识符),这样系统中所有的连接都持有唯一的一对套接字及端口连接,对于来自不同应用程序进程或网络连接的通信,能够方便地加以区分,确保了通信双方之间逻辑链路的唯一性,便于实现数据传输的并发服务,而且隐藏了通信设施及实现细节,采用统一的接口进行处理 </p><h4 id="远程过程调用和远程方法调用" tabindex="-1"><a class="header-anchor" href="#远程过程调用和远程方法调用" aria-hidden="true">#</a> 远程过程调用和远程方法调用</h4><p>远程过程(函数)调用RPC(Remote Procedure Call),是一个通信协议,用于通过网络连接的系统。该协议允许运行于一台主机(本地)系统上的进程调用另一台主机(远程)系统上的进程,而对程序员表现为常规的过程调用,无需额外地为此编程。如果涉及的软件采用面向对象编程,那么远程过程调用亦可称做远程方法调用。负责处理远程过程调用的进程有两个,一个是本地客户进程,另一个是远程服务器进程,这两个进程通常也被称为网络守护进程,主要负责在网络间的消息传递,一般情况下这两个进程都是处于阻塞状态,等待消息为了使远程过程调用看上去与本地过程调用一样,即希望实现RPC的透明性,使得调用者感觉不到此次调用的过程是在其他主机(远程)上执行的,RPC引入一个存根(stub)的概念:在本地客户端,每个能够独立运行的远程过程都拥有一个客户存根( client stubborn),本地进程调用远程过程实际是调用该过程关联的存根;与此类似,在每个远程进程所在的服务器端,其所对应的实际可执行进程也存在一个服务器存根(stub)与其关联。本地客户存根与对应的远程服务器存根一般也是处于阻塞状态,等待消息。</p><p>实际上,远程过程调用的主要步骤是:</p><p>(1)本地过程调用者以一般方式调用远程过程在本地关联的客户存根,传递相应的参数,然后将控制权转移给客户存根:</p><p>(2)客户存根执行,完成包括过程名和调用参数等信息的消息建立,将控制权转移给本地客户进程;</p><p>(3)本地客户进程完成与服务器的消息传递,将消息发送到远程服务器进程;</p><p>(4)远程服务器进程接收消息后转入执行,并根据其中的远程过程名找到对应的服务器存根,将消息转给该存根;</p><p>(5)该服务器存根接到消息后,由阻塞状态转入执行状态,拆开消息从中取出过程调用的参数,然后以一般方式调用服务器上关联的过程;</p><p>(6)在服务器端的远程过程运行完毕后,将结果返回给与之关联的服务器存根;<p>(7)该服务器存根获得控制权运行,将结果打包为消息,并将控制权转移给远程服务器进程;</p>(8)远程服务器进程将消息发送回客户端;</p><p>(9)本地客户进程接收到消息后,根据其中的过程名将消息存入关联的客户存根,再将控制权转移给客户存根;</p><p>(10)客户存根从消息中取出结果,返回给本地调用者进程,并完成控制权的转移。</p><p> 这样,本地调用者再次获得控制权,并且得到了所需的数据,得以继续运行。显然,上述步骤的主要作用在于:将客户过程的本地调用转化为客户存根,再转化为服务器过程的本地调用,对客户与服务器来说,它们的中间步骤是不可见的,因此,调用者在整个过程中并不知道该过程的执行是在远程,而不是在本地。</p><h3 id="消息传递通信的实现方式" tabindex="-1"><a class="header-anchor" href="#消息传递通信的实现方式" aria-hidden="true">#</a> 消息传递通信的实现方式</h3><p>在进程之间通信时,源进程可以直接或间接地将消息传送给目标进程,因此可将进程通信分为直接和间接两种通信方式。常见的直接消息传递系统和信箱通信就是分别采用这两种通信方式。</p><h4 id="直接消息传递系统" tabindex="-1"><a class="header-anchor" href="#直接消息传递系统" aria-hidden="true">#</a> 直接消息传递系统</h4><p>在直接消息传递系统中采用直接通信方式,即发送进程利用OS所提供的发送命令(原语),直接把消息发送给目标进程。</p><h5 id="直接通信原语" tabindex="-1"><a class="header-anchor" href="#直接通信原语" aria-hidden="true">#</a> 直接通信原语</h5><ol><li>对称寻址方式。该方式要求发送进程和接收进程都必须以显式方式提供对方的标识符。通常,系统提供下述两条通信命令(原语):</li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>    send(receiver, message); //发送一个消息给接收进程
    receive(sender, message); //接收Sender发来的消息
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>例如,原语Send(P2, ml)表示将消息m1发送给接收进程P2;而原语Receive(P1, m1)则表示接收由P1发来的消息ml. 对称寻址方式的不足在于,一旦改变进程的名称,则可能需要检查所有其它进程的定义,有关对该进程旧名称的所有引用都必须查找到,以便将其修改为新名称,显然,这样的方式不利于实现进程定义的模块化。 2. 非对称寻址方式。在某些情况下,接收进程可能需要与多个发送进程通信,无法事先指定发送进程。例如,用于提供打印服务的进程,它可以接收来自任何一个进程的“打印请求”消息。对于这样的应用,在接收进程的原语中,不需要命名发送进程,只填写表示源进程的参数,即完成通信后的返回值,而发送进程仍需要命名接收进程。该方式的发送和接收原语可表示为: send(P, message); 发送一个消息给进程Preceive (id, message);接收来自任何进程的消息, id变量可设置为进行通信的发送方进程id或名字。</p><h5 id="消息的格式" tabindex="-1"><a class="header-anchor" href="#消息的格式" aria-hidden="true">#</a> 消息的格式</h5><p>在消息传递系统中所传递的消息,必须具有一定的消息格式。在单机系统环境中,由于发送进程和接收进程处于同一台机器中,有着相同的环境,所以消息的格式比较简单,可采用比较短的定长消息格式,以减少对消息的处理和存储开销。该方式可用于办公自动化系统中,为用户提供快速的便笺式通信。但这种方式对于需要发送较长消息的用户是不方便的。为此,可采用变长的消息格式,即进程所发送消息的长度是可变的。对于变长消息,系统无论在处理方面还是存储方面,都可能会付出更多的开销,但其优点在于方便了用户。</p><h5 id="进程的同步方式" tabindex="-1"><a class="header-anchor" href="#进程的同步方式" aria-hidden="true">#</a> 进程的同步方式</h5><p>在进程之间进行通信时,同样需要有进程同步机制,以使诸进程间能协调通信。不论是发送进程还是接收进程,在完成消息的发送或接收后,都存在两种可能性,即进程或者继续发送(或接收)或者阻塞。由此,我们可得到三种情况: 0发送进程阻塞,接收进程阻塞。这种情况主要用于进程之间紧密同步,发送进程和接收进程之间无缓冲时。2发送进程不阻塞、接收进程阻塞。这是一种应用最广的进程同步方式。平时,发送进程不阻塞,因而它可以尽快地把一个或多个消息发送给多个目标;而接收进程平时则处于阻塞状态,直到发送进程发来消息时才被唤醒。3发送进程和接收进程均不阻塞。这也是一种较常见的进程同步形式。平时,发送进程和接收进程都在忙于自己的事情,仅当发生某事件使它无法继续运行时,才把自己阻塞起来等待。</p><h5 id="通信链路" tabindex="-1"><a class="header-anchor" href="#通信链路" aria-hidden="true">#</a> 通信链路</h5><p>为使在发送进程和接收进程之间能进行通信,必须在两者之间建立一条通信链路。有两种方式建立通信链路。第一种方式是:由发送进程在通信之前用显式的“建立连接”命令(原语)请求系统为之建立一条通信链路,在链路使用完后拆除链路。这种方式主要用于计算机网络中。第二种方式是:发送进程无须明确提出建立链路的请求,只须利用系统提供的发送命令(原语),系统会自动地为之建立一条链路。这种方式主要用于单机系统中。而根据通信方式的不同,则又可把链路分成两种:</p><ol><li>单向通信链路,只允许发送进程向接收进程发送消息,或者相反;</li><li>双向通信链路,既允许由进程A向进程B发送消息,也允许进程B同时向进程A发送消息。</li></ol><h4 id="信箱通信" tabindex="-1"><a class="header-anchor" href="#信箱通信" aria-hidden="true">#</a> 信箱通信</h4><p>信箱通信属于间接通信方式,即进程之间的通信,需要通过某种中间实体(如共享数据结构等)来完成。该实体建立在随机存储器的公用缓冲区上,用来暂存发送进程发送给目标进程的消息:接收进程可以从该实体中取出发送进程发送给自己的消息,通常把这种中间实体称为邮箱(或信箱),每个邮箱都有一个唯一的标识符。消息在邮箱中可以安全地保存,只允许核准的目标用户随时读取。因此,利用邮箱通信方式既可实现实时通信,又可实现非实时通信。</p><h5 id="信箱的结构" tabindex="-1"><a class="header-anchor" href="#信箱的结构" aria-hidden="true">#</a> 信箱的结构</h5><p>信箱定义为一种数据结构。在逻辑上,可以将其分为两个部分:</p><ol><li>信箱头,用以存放有关信箱的描述信息,如信箱标识符、信箱的拥有者、信箱口令、信箱的空格数等;</li><li>信箱体,由若干个可以存放消息(或消息头)的信箱格组成,信箱格的数目以及每格的大小是在创建信箱时确定的。</li></ol><p> 在消息传递方式上,最简单的情况是单向传递。消息的传递也可以是双向的。图2-16示出了双向通信链路的通信方式。 </p><figure><img src="/blognext/images/2-16.png" alt="2-16" tabindex="0" loading="lazy"><figcaption>2-16</figcaption></figure><h5 id="信箱通信原语" tabindex="-1"><a class="header-anchor" href="#信箱通信原语" aria-hidden="true">#</a> 信箱通信原语</h5><p>系统为邮箱通信提供了若干条原语,分别用于:</p><p>(1)邮箱的创建和撤消。进程可利用邮箱创建原语来建立一个新邮箱,创建者进程应给出邮箱名字、邮箱属性(公用、私用或共享);对于共享邮箱,还应给出共享者的名字。 当进程不再需要读邮箱时,可用邮箱撤消原语将之撤消。</p><p>(2)消息的发送和接收。当进程之间要利用邮箱进行通信时,必须使用共享邮箱,并利用系统提供的下述通信原语进行通信。</p><p>Send(mailbox, message); 将一个消息发送到指定邮箱Receive(mailbox, message);: 从指定邮箱中接收一个消息3)信箱的类型邮箱可由操作系统创建,也可由用户进程创建,创建者是邮箱的拥有者。据此,可把邮箱分为以下三类:</p><p>(1)私用邮箱。用户进程可为自己建立一个新邮箱,并作为该进程的一部分。邮箱的拥有者有权从邮箱中读取消息,其他用户则只能将自己构成的消息发送到该邮箱中。这种私用邮箱可采用单向通信链路的邮箱来实现。当拥有该邮箱的进程结束时,邮箱也随之消失。</p><p>(2)公用邮箱。由操作系统创建,并提供给系统中的所有核准进程使用。核准进程既可把消息发送到该邮箱中,也可从邮箱中读取发送给自己的消息。显然,公用邮箱应采用双向通信链路的邮箱来实现。通常,公用邮箱在系统运行期间始终存在。</p><p>(3)共享邮箱。由某进程创建,在创建时或创建后指明它是可共享的,同时须指出共享进程(用户)的名字。邮箱的拥有者和共享者都有权从邮箱中取走发送给自己的消息。</p><p>在利用邮箱通信时,在发送进程和接收进程之间,存在以下四种关系:</p><ol><li>一对一关系。发送进程和接收进程可以建立一条两者专用的通信链路,使两者之间的交互不受其他进程的干扰。</li><li>多对一关系。允许提供服务的进程与多个用户进程之间进行交互,也称为客户/服务器交互(clienvserver interaction).</li><li>一对多关系。允许一个发送进程与多个接收进程进行交互,使发送进程可用广播方式向接收者(多个)发送消息。</li><li>多对多关系。允许建立一个公用邮箱,让多个进程都能向邮箱中投递消息;也可从邮箱中取走属于自己的消息。</li></ol><h3 id="直接消息传递系统实例" tabindex="-1"><a class="header-anchor" href="#直接消息传递系统实例" aria-hidden="true">#</a> 直接消息传递系统实例</h3><p>消息缓冲队列通信机制首先由美国的Hansan提出,并在RC 4000系统上实现,后来被广泛应用于本地进程之间的通信中。在这种通信机制中,发送进程利用Send原语将消息直接发送给接收进程:接收进程则利用Receive原语接收消息。</p><h4 id="消息缓冲队列通信机制中的数据结构" tabindex="-1"><a class="header-anchor" href="#消息缓冲队列通信机制中的数据结构" aria-hidden="true">#</a> 消息缓冲队列通信机制中的数据结构</h4><p>(1)消息缓冲区。</p> 在消息缓冲队列通信方式中,主要利用的数据结构是消息缓冲区。它可描述如下: <div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>    type struct message_buffer{
        int sender;//发送者进程标识符
        int size;//消息长度
        char *text;//消息正文
        struct message_buffer *next //指向下一个消息缓冲区的指针
    }

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>(2) PCB中有关通信的数据项。</p> 在操作系统中采用了消息缓冲队列通信机制时,除了需要为进程设置消息缓冲队列外,还应在进程的PCB中增加消息队列队首指针,用于对消息队列进行操作,以及用于实现同步的互斥信号量mutex和资源信号量sm。在PCB中应增加的数据项可描述如下: <div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>    type struct processcontrol_block{
        ...
        struct message_buffer *mq ;// 消息队列队首指针
        semaphore mutex;// 消息队列互斥信号量
        semaphore sm; //消息队列资源信号量|PCB;
    }
   
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="发送原语" tabindex="-1"><a class="header-anchor" href="#发送原语" aria-hidden="true">#</a> 发送原语</h4><p>发送进程在利用发送原语发送消息之前,应先在自己的内存空间设置一发送区a,如图2-17所示,把待发送的消息正文、发送进程标识符、消息长度等信息填入其中,然后调用发送原语,把消息发送给目标(接收)进程。发送原语首先根据发送区a中所设置的消息长度a.size来申请一缓冲区i,接着,把发送区a中的信息复制到缓冲区i中。为了能将i挂在接收进程的消息队列mq上,应先获得接收进程的内部标识符j,然后将i挂在j.mq上由于该队列属于临界资源,故在执行insert操作的前后都要执行wat和signal操作。</p><figure><img src="/blognext/images/2-17.png" alt="2-17" tabindex="0" loading="lazy"><figcaption>2-17</figcaption></figure><p>发送原语可描述如下:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>    void send (receiver, a){ //receiver为接收进程标识符,a为发送区首址
        getbuf(a.size, i); // 根据a.size申请缓冲区;
        copy(i.sender, a.sender);//  将发送区a中的信息复制到消息缓冲区i中
        copy(i.text, a.text);
        i.next=0;
        getid(PCBset, receiver.j);//获得接收进程内部的标识符
        insert(&amp;j.mq, i);//将消息缓冲区插入消息队列
        signal(j.sm);
    }   
  
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="接收原语" tabindex="-1"><a class="header-anchor" href="#接收原语" aria-hidden="true">#</a> 接收原语</h4><p>接收进程调用接收原语 receive(b),从自己的消息缓冲队列mq中摘下第一个消息缓冲区i,并将其中的数据复制到以b为首址的指定消息接收区内。接收原语描述如下:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>    void receive(b){
        j=internal name; //j为接收进程内部的标识符
        wait(j.sm);
        wait(j.mutex)
        remove(j.mq, i); //将消息队列中第一个消息移出
        signal(j.mutex);
        copy(b.sender,i.sender);//将消息缓冲区i中的信息复制到接受区b
        b.size = i.size;
        copy(b.text,i.text);
        releasebuf(i); //释放消息缓冲区
    }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/eaaomk/edit/main/docs/posts/os/5.md" rel="noopener noreferrer" target="_blank" aria-label="在 GitHub 上编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->在 GitHub 上编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><div class="contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: eaaomk@163.com">qiang.zhang</span><!--]--><!--]--></div></div></footer><nav class="page-nav"><a href="/blognext/posts/os/3.html" class="nav-link prev" aria-label="进程控制"><div class="hint"><span class="arrow left"></span>上一页</div><div class="link"><!---->进程控制</div></a><a href="/blognext/posts/os/4.html" class="nav-link next" aria-label="进程同步"><div class="hint">下一页<span class="arrow right"></span></div><div class="link">进程同步<!----></div></a></nav><div class="giscus-wrapper input-top" id="comment" style="display:block;"><div style="text-align:center">Loading...</div></div><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer">android 天花板</div><div class="copyright">Copyright © 2023 qiang.zhang</div></footer></div><!--]--><!----><!--]--></div>
    <script type="module" src="/blognext/assets/app-72b3b0cc.js" defer></script>
  </body>
</html>
